### **Comprehensive Kubernetes Notes**

---

#### **1. Introduction to Kubernetes**
- **Definition**: Kubernetes is an open-source container orchestration framework originally developed by Google. It manages containerized applications (e.g., Docker containers) across physical, virtual, cloud, or hybrid environments.
- **Core Problems Solved**:
  - **High Availability**: Ensures applications have no downtime.
  - **Scalability**: Manages application performance under load.
  - **Disaster Recovery**: Restores applications/data to the latest state after failures.
- **Why Kubernetes?**: 
  - Rise of microservices → Increased container usage → Need to manage hundreds/thousands of containers efficiently.

---

#### **2. Core Kubernetes Components**
- **Pod**: 
  - Smallest unit; abstraction over a container. 
  - Typically runs one main application container + optional helper containers (sidecars).
- **Service**: 
  - Provides a static IP address for pods (stable endpoint). 
  - Load balances traffic across pod replicas.
  - Types: 
    - **Internal (ClusterIP)**: Accessible only within the cluster.
    - **External (LoadBalancer)**: Exposes pods to external traffic.
- **Ingress**: 
  - Routes external HTTP/HTTPS traffic to services. 
  - Provides domain-based routing (e.g., `myapp.com` → `my-service`).
- **ConfigMap**: 
  - Stores non-confidential configuration data (e.g., database URLs).
- **Secret**: 
  - Stores sensitive data (e.g., passwords, certificates) in base64-encoded format.
- **Volume**: 
  - Attaches persistent storage (local or remote) to pods. Data survives pod restarts.
- **Deployment**: 
  - Manages stateless applications. 
  - Defines pod blueprints, replica counts, and rolling updates.
- **StatefulSet**: 
  - Manages stateful applications (e.g., databases). 
  - Ensures ordered deployment, stable network identities, and persistent storage.

---

#### **3. Kubernetes Architecture**
- **Worker Nodes**: Run application workloads.
  - **Processes**:
    - **Container Runtime** (e.g., Docker): Runs containers.
    - **Kubelet**: Starts pods and manages resources.
    - **Kube Proxy**: Handles network routing and load balancing.
- **Master Nodes (Control Plane)**: Manage cluster state.
  - **Processes**:
    - **API Server**: Entry point for cluster interactions (e.g., via `kubectl`).
    - **Scheduler**: Assigns pods to nodes based on resources.
    - **Controller Manager**: Monitors/remediates cluster state (e.g., restarts failed pods).
    - **etcd**: Distributed key-value store storing cluster state.
- **Cluster Setup**:
  - Production: Multiple master nodes for high availability.
  - Worker nodes scale horizontally as resource demands increase.

---

#### **4. Minikube and kubectl**
- **Minikube**: 
  - Local single-node Kubernetes cluster (runs in a VM).
  - Ideal for development/testing.
  - Setup: 
    ```bash
    minikube start --vm-driver=hyperkit  # macOS example
    ```
- **kubectl**: 
  - CLI tool to interact with Kubernetes clusters.
  - Key Commands:
    - `kubectl get pods`: List pods.
    - `kubectl create deployment nginx --image=nginx`: Create a deployment.
    - `kubectl logs <pod-name>`: View pod logs.
    - `kubectl exec -it <pod-name> -- /bin/bash`: Access a pod's shell.
    - `kubectl apply -f config.yaml`: Deploy resources from a YAML file.

---

#### **5. Kubernetes Configuration Files (YAML)**
- **Structure**:
  - **Metadata**: Name, labels, namespace.
  - **Spec**: Desired state (e.g., container image, replicas).
  - **Status**: Actual state (auto-generated by Kubernetes).
- **Key Fields**:
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
  spec:
    replicas: 2
    template:
      spec:
        containers:
        - name: nginx
          image: nginx:1.16
          ports:
          - containerPort: 80
  ```
- **Labels & Selectors**: 
  - Link components (e.g., Service → Pods via `app: nginx` label).

---

#### **6. Deploying Applications: MongoDB + Express**
1. **MongoDB Setup**:
   - **Secret**: Store database credentials.
     ```yaml
     apiVersion: v1
     kind: Secret
     metadata:
       name: mongodb-secret
     type: Opaque
     data:
       username: base64-encoded
       password: base64-encoded
     ```
   - **Deployment**: Mount secrets as environment variables.
   - **Service**: Internal `ClusterIP` service (`mongodb-service`).
2. **Express Setup**:
   - **ConfigMap**: Store MongoDB endpoint URL.
   - **Deployment**: Reference ConfigMap/Secrets for environment variables.
   - **Service**: External `LoadBalancer` service for web access.
3. **Access**:
   ```bash
   minikube service express-service  # Opens Express in browser
   ```

---

#### **7. Namespaces**
- **Purpose**: Organize resources into virtual clusters (e.g., `dev`, `prod`).
- **Default Namespaces**:
  - `kube-system`: System components.
  - `default`: User resources (if no namespace specified).
- **Commands**:
  ```bash
  kubectl create namespace dev
  kubectl get pods -n dev
  kubens dev  # Switch active namespace (using kubens)
  ```

---

#### **8. Ingress**
- **Role**: Routes external traffic to internal services (e.g., `myapp.com` → `my-service`).
- **Ingress Controller**: Implements Ingress rules (e.g., Nginx Ingress Controller).
- **Setup**:
  1. Enable in Minikube: `minikube addons enable ingress`.
  2. Define Ingress rules:
     ```yaml
     apiVersion: networking.k8s.io/v1
     kind: Ingress
     metadata:
       name: my-ingress
     spec:
       rules:
       - host: myapp.com
         http:
           paths:
           - path: /
             pathType: Prefix
             backend:
               service:
                 name: my-service
                 port: 
                   number: 80
     ```
  3. Update `/etc/hosts` to map `myapp.com` to Minikube IP.

---

#### **9. Helm**
- **Package Manager**: Manages Kubernetes applications as "charts".
- **Chart Structure**:
  - `values.yaml`: Default configuration.
  - `templates/`: Kubernetes manifests with placeholders (e.g., `{{ .Values.image }}`).
- **Commands**:
  ```bash
  helm install my-app ./my-chart  # Deploy a chart
  helm upgrade my-app ./my-chart  # Update a release
  ```
- **Helm 3 vs Helm 2**: Helm 3 removed `tiller` (server component) for security.

---

#### **10. Persistent Storage**
- **PersistentVolume (PV)**: Cluster storage resource (e.g., NFS, AWS EBS).
- **PersistentVolumeClaim (PVC)**: User request for storage (binds to PV).
- **StorageClass**: Dynamically provisions PVs (e.g., `standard` on GCP).
- **Example PVC**:
  ```yaml
  apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: my-pvc
  spec:
    storageClassName: standard
    accessModes:
      - ReadWriteOnce
    resources:
      requests:
        storage: 10Gi
  ```

---

#### **11. StatefulSets**
- **Use Case**: Stateful applications (e.g., databases).
- **Features**:
  - Stable pod names (`mysql-0`, `mysql-1`).
  - Ordered deployment/scaling (pod `n` starts after `n-1` is ready).
  - Persistent storage per pod (via PVCs).
- **vs Deployments**: Deployments are for stateless apps; StatefulSets for stateful apps.

---

#### **12. Kubernetes Services**
- **Types**:
  - **ClusterIP**: Internal service (default).
  - **NodePort**: Exposes service on a static node port (e.g., `:30000`).
  - **LoadBalancer**: Cloud provider-managed external IP.
  - **Headless**: Direct pod access (no load balancing; used for stateful apps).
- **Multi-port Services**:
  ```yaml
  spec:
    ports:
    - name: http
      port: 80
      targetPort: 8080
    - name: metrics
      port: 9100
      targetPort: 9100
  ```

---

### **Summary**
Kubernetes automates deployment, scaling, and management of containerized applications. Core components (Pods, Services, Deployments, etc.) work together to provide high availability, scalability, and resilience. Tools like Minikube (local testing), Helm (package management), and kubectl (CLI) simplify interaction. Persistent storage (PVs/PVCs) and StatefulSets handle stateful workloads, while Ingress manages external access. Namespaces organize resources, and ConfigMaps/Secrets manage configurations. 

**Next Steps**: Practice with Minikube, deploy sample apps, and explore Helm charts for complex deployments.
